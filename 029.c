// How many distinct terms are in the sequence generated by ab for 2 ≤ a ≤ 100 and 2 ≤ b ≤ 100?


// NOT A VERY GOOD IMPLEMENTATION

#include <stdio.h>
#include <stdbool.h>
#include <math.h>

int main() {
  bool existsInArr(int n, int *arr);
  void resetArr(int *arr);
  
  int arr[9801] = {0};
  int root_arr[9801] = {0};
  int next_arr_i = 0;
  int next_root_arr_i = 0;
  int this_root;
  int this_prod;
  int dupe_count = 0;
  
  const int min = 2; 
  const int max = 100;
  const int combos = pow((max - min) + 1, 2);
    
  for (int x = min; x <= max; x++) {
    for (int exp1 = 1; (this_root = pow(x, exp1)) <= max; exp1++) {
      if (existsInArr(this_root, root_arr)) {
        break;
      } else {
        root_arr[next_root_arr_i++] = this_root;
      }
      
      for (int exp2 = min; exp2 <= max; exp2++) {
        this_prod = exp1 * exp2;
        if (existsInArr(this_prod, arr)) {
          dupe_count++;
          printf("%i ^ %i ^ %i\n", x, exp1, exp2); // TEST
        } else {
          arr[next_arr_i++] = this_prod;
        }
      }
    }
    resetArr(arr);
    next_arr_i = 0;
  }
  
  
  printf("%i - %i = %i\n", combos, dupe_count, combos - dupe_count);
  
  return 0;
}


bool existsInArr(int n, int *arr) {
  while (*arr != 0) {
    if (*arr == n) {
      return true;
    }
    arr++;
  }
  return false;
}

void resetArr(int *arr) {
  while (*arr != 0) {
    *arr = 0;
    arr++;
  }
}